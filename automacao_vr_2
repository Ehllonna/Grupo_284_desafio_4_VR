import streamlit as st
import pandas as pd
import zipfile 
import io

# Título da aplicação
st.title('Valle.ai - Assistente inteligente para projeto de Vale-Alimentação/Refeição')
st.markdown('### Carregue o arquivo zip contendo as planilhas para processamento')

# Dicionário para armazenar os DataFrames extraídos do ZIP
dataframes = {}

# Passo 1: Upload do arquivo ZIP
zip_file = st.file_uploader("Selecione ou arraste o arquivo ZIP aqui", type=["zip"])

if zip_file is not None:
    # Mostra uma mensagem de progresso
    with st.spinner("Extraindo arquivos..."):
        try:
            with zipfile.ZipFile(zip_file, 'r') as z:
                # Extrai os arquivos para um dicionário de DataFrames
                for file_name in z.namelist():
                    if file_name.endswith(".xlsx") and not file_name.startswith('__MACOSX'):
                        with z.open(file_name) as f:
                            # Tenta ler com header na linha 1 e ajusta para casos específicos
                            try:
                                # Adicionando o 'engine' explicitamente aqui
                                df = pd.read_excel(io.BytesIO(f.read()), header=1, engine='openpyxl')
                            except Exception:
                                # E aqui também, na exceção
                                df = pd.read_excel(io.BytesIO(f.read()), header=0, engine='openpyxl')
                            
                            # Limpa os nomes das colunas
                            df.columns = df.columns.str.strip().str.upper()
                            # Armazena o DataFrame no dicionário usando o nome do arquivo (sem a extensão) como chave
                            key = file_name.split('/')[-1].replace('.xlsx', '').upper().replace(' ', '_')
                            dataframes[key] = df
            
            st.success("Arquivos extraídos com sucesso!")
            st.info(f"Arquivos carregados: {list(dataframes.keys())}")
            
        except Exception as e:
            st.error(f"Ocorreu um erro ao extrair o ZIP: {e}")
            dataframes = {}

# --- Botão e Lógica de Processamento ---
# Este botão só aparece e só funciona se os DataFrames foram carregados
if dataframes and st.button('Processar'):
    st.write("Iniciando o processamento dos dados...")
    
    try:
        # --- Etapa 1: Consolidar as bases de dados ---
        st.write("Consolidando bases ATIVOS e ADMISSÃO ABRIL...")
        
        # Força o pandas a ignorar qualquer índice original
        base_ativos = dataframes['ATIVOS'].reset_index(drop=True)
        base_admissao = dataframes['ADMISSÃO_ABRIL'].reset_index(drop=True)
        
        # Combina as duas bases em uma única, ignorando o índice.
        base_final = pd.concat([base_ativos, base_admissao], ignore_index=True)
        
        # --- Etapa 2: Excluir os colaboradores não elegíveis ---
        st.write("Excluindo colaboradores desligados, afastados, de férias, estagiários e aprendizes...")
        
        # Cria uma lista de matrículas a serem excluídas a partir de todas as fontes
        matriculas_a_excluir = set()
        
        # Adiciona matrículas da planilha de desligados
        if 'DESLIGADOS' in dataframes and 'MATRICULA' in dataframes['DESLIGADOS'].columns:
            matriculas_a_excluir.update(dataframes['DESLIGADOS']['MATRICULA'].astype(str).tolist())
        
        # Adiciona matrículas da planilha de afastamentos
        if 'AFASTAMENTOS' in dataframes and 'MATRICULA' in dataframes['AFASTAMENTOS'].columns:
            matriculas_a_excluir.update(dataframes['AFASTAMENTOS']['MATRICULA'].astype(str).tolist())
        
        # Adiciona matrículas da planilha de exterior
        if 'EXTERIOR' in dataframes and 'CADASTRO' in dataframes['EXTERIOR'].columns:
            matriculas_a_excluir.update(dataframes['EXTERIOR']['CADASTRO'].astype(str).tolist())
            
        # Filtra a base final com base nas matrículas a excluir
        base_final = base_final[~base_final['MATRICULA'].astype(str).isin(matriculas_a_excluir)]
        
        # Exclui colaboradores de férias com base na coluna 'DESC. SITUACAO'
        base_final = base_final[~base_final['DESC. SITUACAO'].astype(str).str.contains('FÉRIAS', na=False, case=False)]
        
        # Exclui estagiários e aprendizes
        titulos_a_excluir = pd.concat([
            dataframes['ESTAGIO']['TITULO DO CARGO'].astype(str), 
            dataframes['APRENDIZ']['TITULO DO CARGO'].astype(str)
        ]).unique().tolist()
        base_final = base_final[~base_final['TITULO DO CARGO'].astype(str).isin(titulos_a_excluir)]
        
        # Adiciona nova lógica para a coluna 'Observações' se ela existir
        if 'OBSERVAÇÕES' in base_final.columns:
            st.write("Aplicando filtros com base na coluna 'Observações'...")
            # Padrões para exclusão: palavras como 'desligado', 'sem VR', 'não usa' etc.
            padroes_exclusao = r'desligado|sem vr|nao usa|n\s?o\s?utiliza|demitido|retorno|removido'
            base_final = base_final[~base_final['OBSERVAÇÕES'].astype(str).str.contains(padroes_exclusao, case=False, na=False)]
        
        st.success("Exclusões realizadas com sucesso!")

        # --- Etapa 3: Mesclar com bases de dias úteis e valores do sindicato ---
        st.write("Mesclando com as bases de dias úteis e valores de sindicato...")
        
        # Limpar e converter a coluna 'SINDICATO' para string
        base_final['SINDICATO'] = base_final['SINDICATO'].astype(str).str.strip()

        # Mesclar com a base de dias úteis
        dias_uteis_df = dataframes['BASE_DIAS_UTEIS'].copy()
        dias_uteis_df.rename(columns={'SINDICADO': 'SINDICATO', 'DIAS UTEIS ': 'DIAS'}, inplace=True)
        dias_uteis_df['SINDICATO'] = dias_uteis_df['SINDICATO'].astype(str).str.strip()
        base_final = pd.merge(base_final, dias_uteis_df[['SINDICATO', 'DIAS']], on='SINDICATO', how='left')
        
        # Mapear a sigla do estado para o nome completo para o merge com a base de valores
        sindicato_valor_df = dataframes['BASE_SINDICATO_X_VALOR'].copy()
        sindicato_valor_df.rename(columns={'ESTADO': 'ESTADO', 'VALOR': 'VALOR DIÁRIO VR'}, inplace=True)
        sindicato_valor_df['ESTADO'] = sindicato_valor_df['ESTADO'].astype(str).str.strip().str.upper()

        sindicato_mapping = {
            'SP': 'SÃO PAULO',
            'RS': 'RIO GRANDE DO SUL',
            'PR': 'PARANÁ',
            'RJ': 'RIO DE JANEIRO'
        }
        # Extração mais robusta da sigla do estado
        base_final['ESTADO'] = base_final['SINDICATO'].astype(str).str.split(' - ').str[0].str[-2:].str.strip().str.upper().map(sindicato_mapping)
        
        # Fazer o merge com a base de valores de sindicato
        base_final = pd.merge(base_final, sindicato_valor_df, on='ESTADO', how='left')

        st.success("Mesclagem concluída!")

        # --- Etapa 4: Calcular o valor do benefício ---
        st.write("Realizando os cálculos finais...")

        # Convertendo as colunas para números antes do cálculo
        base_final['DIAS'] = pd.to_numeric(base_final['DIAS'], errors='coerce').fillna(0)
        base_final['VALOR DIÁRIO VR'] = pd.to_numeric(base_final['VALOR DIÁRIO VR'], errors='coerce').fillna(0)
        
        base_final['TOTAL'] = base_final['DIAS'] * base_final['VALOR DIÁRIO VR']
        base_final['Custo empresa'] = base_final['TOTAL'] * 0.80
        base_final['Desconto profissional'] = base_final['TOTAL'] * 0.20
        
        # Limpar colunas de mesclagem para o relatório final
        base_final.drop(columns=['ESTADO'], inplace=True, errors='ignore')
        
        st.success('Processamento concluído! O arquivo está pronto para download.')
        
        # --- Etapa 5: Gerar o arquivo Excel para download ---
        output = io.BytesIO()
        with pd.ExcelWriter(output, engine='xlsxwriter') as writer:
            base_final.to_excel(writer, index=False, sheet_name='Base Final')
        output.seek(0)
        
        st.download_button(
            label="Clique para baixar o arquivo",
            data=output,
            file_name="Base_VR_Pronta.xlsx",
            mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
        )

    except Exception as e:
        st.error(f"Ocorreu um erro durante o processamento: {e}")
        st.warning("Por favor, verifique se os arquivos estão corretos e tente novamente.")
